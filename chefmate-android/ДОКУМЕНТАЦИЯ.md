Документация на проект ChefMate 

Увод 

Нещо обикновено като приготвянето на храна вкъщи може да отнеме много време: от това да се намери подходяща рецепта, до това да се състави списък с продукти, или да се проследят стъпките по време на готвене. 

Готвачите от своя страна пък постоянно трябва да следят рецептите, да записват нови идеи, да управляват списъците си с покупки и да се справят с неочаквани ситуации по време на приготвяне. 

От друга страна за начинаещите готвачи би било много по-удобно да разполагат с помощ и насоки по всяко време, особено когато се сблъскват с трудности по време на готвене. 

И тъй като в съвременния ни свят огромна част от хората разполагат с мобилни телефони, които носят със себе си навсякъде, мобилно приложение би бил добър начин за решаване на тези проблеми. 

Решението е мобилно приложение, с помощта на което всеки потребител да може да разглежда и търси рецепти, да създава собствени рецепти, да управлява списъците си с покупки и да получава помощ от изкуствен интелект по време на готвене. 

Потребителите да могат да запазват любими рецепти, да коментират и да споделят опит, както и да използват режим на готвене с гласови команди, за да не се налага да докосват устройството с мръсни ръце. 

Добавянето на административен панел позволява управление на потребителите и рецептите от всяка точка на света. 

Ето защо тази дипломна работа има за цел разработването на приложение, което да е от полза, както на начинаещите, така и на опитните готвачи, и администраторите на платформата. 

Цели и задачи на дипломната работа 

Основна цел: 

Разработване на мобилно приложение за управление на рецепти с иновативни функции за помощ по време на готвене, което да улесни процеса на приготвяне на храна както за начинаещи, така и за опитни готвачи. 

Основни задачи: 

Проучване на съществуващите решения за управление на рецепти и анализ на техните предимства и недостатъци 

Избор и обосновка на подходящи технологии за разработка на мобилното приложение и сървърната част 

Проектиране на архитектурата на приложението с използване на MVVM модел и REST API комуникация 

Проектиране и реализация на база данни за съхранение на рецепти, потребители, коментари и списъци с покупки 

Реализация на функционалности за: 

Регистрация и автентикация на потребители 

Разглеждане, търсене и филтриране на рецепти 

Създаване и редактиране на рецепти 

Управление на списъци с покупки 

Режим на готвене с интерактивни функции 

Гласови команди за управление на приложението 

AI помощник за съвети по време на готвене 

Социални функции (харесвания, коментари) 

Административен панел за управление 

Тестване на функционалностите на приложението 

Създаване на документация и ръководство за потребителите 

 

 

 

 

 

 

 

 

 

1. Първа глава: Технологии и подобни приложения 

1.1 Технологии  

1.1.1 Android  

Android[1] представлява софтуерна платформа с отворен код, изградена върху Linux ядро, предназначена за разнообразен спектър от мобилни и други устройства.  

Архитектурата на платформата включва следните ключови елементи:  

• Linux ядрото осигурява фундаментални възможности като управление на процеси и памет на системно ниво, както и защитни механизми.  

• Хардуерният слой за абстракция (HAL) дефинира унифицирани интерфейси, които свързват хардуерните компоненти с Java API. Този слой се състои от различни библиотечни модули, всеки от които имплементира специфичен интерфейс за определен хардуерен елемент, например камера или Bluetooth модул.  

• Всяко приложение се изпълнява в изолиран процес с отделна инстанция на Android Runtime (ART). ART е проектиран да поддържа множество виртуални машини на устройства с ограничена памет, като използва DEX файлове, специално създадени за Android платформата. Компилационните инструменти като d8 трансформират Java изходен код в DEX байт код, който се изпълнява в Android средата.  

Платформата съдържа основни изпълними библиотеки, които реализират по-голямата част от функционалностите на Java езика, включително определени възможности от Java 8, използвани от Java API.  

• Значителна част от системните компоненти и услуги на Android, включително ART и HAL, са имплементирани на машинен код, изискващ библиотеки на C и C++. Android платформата предоставя възможност на Java API да взаимодейства с тези библиотеки от приложенията.  

• Пълният функционален набор на Android операционната система се достъпва чрез Java базирани API интерфейси. Тези API формират основните градивни блокове за разработка на Android приложения, улеснявайки преизползването на ядрото, модулните системни компоненти и услуги, сред които са:  

▪ Гъвкава и разширяема система за визуализация (View System), подходяща за конструиране на потребителски интерфейси, включваща списъци, мрежи, текстови полета, бутони и дори вграден уеб браузър.  

▪ Мениджър на ресурси (Resource Manager), който осигурява достъп до некодови ресурси като локализирани текстове, графични елементи и layout файлове.  

▪ Мениджър на известия (Notification Manager), даващ възможност на всички приложения да показват персонализирани уведомления в статус лентата.  

▪ Мениджър на дейности (Activity Manager), отговорен за управление на жизнения цикъл на приложенията и осигуряване на навигационен стек за връщане назад.  

▪ Доставчици на съдържание (Content Providers), които дават възможност на приложенията да достъпват данни от други приложения, като например Контакти, или да споделят собствени данни.  

• Android включва набор от вградени системни приложения за работа с имейли, SMS съобщения, календар, уеб браузър, контакти и други.  

Тези системни приложения служат едновременно като потребителски приложения и като източник на ключови функционалности, достъпни за разработчиците в собствените им приложения.  

1.1.2 Kotlin  

Kotlin[2] е статично типизиран програмен език с отворен код, създаден през 2011 година от JetBrains, и обявен от Google през 2019 година като предпочитан език за разработка на Android приложения. Езикът обединява принципите на обектно-ориентираното и функционалното програмиране.  

От своето възникване през 2011 година, Kotlin претърпява постоянен растеж не само като програмен език, но и като цялостна екосистема, обогатена със зрели инструменти. В днешно време той е напълно интегриран в Android Studio и широко прилаган от компании за създаване на Android приложения.  

Kotlin предлага следните предимства при разработка на Android приложения:  

• Синтаксис, който изисква по-малко код при по-висока четимост.  

• Интеграция с Android Jetpack и други библиотеки. KTX разширенията обогатяват съществуващите Android библиотеки с Kotlin функционалности като корутини (coroutines - модел за паралелно програмиране, опростяващ асинхронния код), ламбда изрази и именувани параметри.  

• Възможност за съвместна употреба с Java в рамките на едно приложение, без необходимост от пълна миграция на кода към Kotlin.  

• Мултиплатформена поддръжка. Kotlin може да се използва не само за Android разработка, но и за създаване на iOS приложения, backend системи и уеб приложения.  

• Лесен за усвояване, особено за разработчици с опит в Java.  

• Активна общност. Kotlin разполага с широка подкрепа и значителни приноси от общността по целия свят. Според данни на Google, над 60% от топ 1000 приложения в Play Store използват Kotlin.  

1.1.3 Среда за разработка Android Studio  

Android Studio[3] е официалната интегрирана среда за разработка (IDE) за Android приложения. Построена върху мощния код редактор и инструменти на IntelliJ IDEA, Android Studio предлага функционалности, които повишават ефективността при създаване на Android приложения, включително:  

• Android Studio използва Gradle като основна система за компилация, с допълнителни Android-специфични възможности, предоставени от Android Gradle плагина. Всеки проект разполага с един главен build файл за целия проект и отделни build файлове на ниво модул за всеки модул. При импортиране на съществуващ проект, Android Studio автоматично генерира необходимите build конфигурации.  

• Високопроизводителен и функционален емулатор.  

• Унифицирана среда за разработка на проекти за всички Android устройства.  

• Възможност за прилагане на промени в кода и ресурсните файлове върху работещо приложение без рестартиране.  

• Широк набор от инструменти и тестови рамки.  

• Lint инструменти за идентифициране на проблеми свързани с производителност, удобство на използване, версионна съвместимост и други.  

• Поддръжка за C++ и NDK (Native Development Kit). 

 

1.1.4 Spring Boot  

Spring Boot[4] е рамка за разработка на Java приложения, която опростява създаването на самостоятелни, производствени приложения, базирани на Spring. Spring Boot позволява бързо създаване на RESTful уеб услуги и микросервиси чрез автоматична конфигурация и вградени зависимости.  

Основните предимства на Spring Boot включват:  

• Автоматична конфигурация - Spring Boot автоматично конфигурира приложението въз основа на добавените зависимости, което намалява необходимостта от ръчна конфигурация.  

• Вградени сървъри - включва вградени Tomcat, Jetty или Undertow сървъри, което позволява бързо стартиране без външни сървъри.  

• Production-ready функции - предоставя вградена поддръжка за мониторинг, метрики и здравни проверки чрез Spring Boot Actuator.  

• Spring Data JPA - опростява работата с бази данни чрез автоматично генериране на SQL заявки.  

• Spring Security - осигурява вградена поддръжка за автентикация и авторизация.  

• RESTful API - улеснява създаването на REST API с автоматична сериализация и десериализация на JSON.  

1.2. Подобни разработени приложения  

1.2.1 AllRecipes  

 

AllRecipes[5] е едно от най-популярните приложения за рецепти в света, което предоставя достъп до над 50,000 рецепти от различни кухни. Приложението позволява на потребителите да:  

• Разглеждат и търсят рецепти по различни критерии (време за приготвяне, трудност, кухня).  

• Създават списъци с покупки от избрани рецепти.  

• Запазват любими рецепти.  

• Четат и пишат отзиви и коментари.  

• Следват стъпките на рецептата с подробни инструкции и снимки.  

 

AllRecipes е достъпно като уеб приложение и мобилно приложение за Android и iOS.  

1.2.2 Yummly  

 

Yummly[6] е интелигентно приложение за рецепти, което използва изкуствен интелект за персонализиране на препоръки. Основните функции включват:  

• AI-базирани препоръки за рецепти въз основа на предпочитанията на потребителя.  

• Филтриране по хранителни ограничения (веган, без глутен, кето и др.).  

• Планиране на меню за седмицата.  

• Интеграция с доставчици на храни за онлайн поръчки.  

• Видео инструкции за приготвяне.  

• Синхронизация между различни устройства.  

1.2.3 Tasty  

 

Tasty[7] е приложение за рецепти от BuzzFeed, известно с кратките си видео клипове за приготвяне. Характеристиките му включват:  

• Кратки видео инструкции за всяка рецепта.  

• Колекции от рецепти по теми (бързи рецепти, десерти, вегетариански и др.).  

• Възможност за запазване на любими рецепти.  

• Списъци с покупки.  

• Таймери за готвене.  

• Режим на готвене с по-големи бутони и по-лесна навигация.  

1.2.4 Разлики между посочените приложения и дипломната работа  

Проектът, предмет на дипломната работа, цели разработването на единно приложение за управление на рецепти, което интегрира множество функционалности в една платформа.  

За разлика от горепосочените приложения, които предоставят предимно функции за разглеждане и следване на рецепти, разработваното приложение ChefMate предлага:  

• Режим на готвене с гласови команди - позволява на потребителите да управляват приложението без да докосват устройството, което е особено полезно по време на готвене с мръсни ръце.  

• Интеграция с изкуствен интелект - AI помощник, който може да отговаря на въпроси по време на готвене и да предоставя персонализирани съвети.  

• Административен панел - позволява на администраторите да управляват потребителите и рецептите от всяка точка на света, което не е налично в повечето потребителски приложения.  

• Създаване и споделяне на рецепти - потребителите могат да създават собствени рецепти и да ги споделят с общността.  

• Коментари и взаимодействие - система за коментари и харесвания, която позволява на потребителите да споделят опит и да получават обратна връзка.  

• Backend с Spring Boot - използва модерна backend архитектура с REST API за по-добра производителност и мащабируемост.  

Горепосочените приложения са предимно ориентирани към потребителите и не предоставят административни функции или иновативни функции като гласови команди по време на готвене.  

 

 

 

 

 

 

 

 

2. Втора глава: Проектиране на структурата на мобилното приложение 

2.1 Функционални изисквания на мобилното приложение  

• Мобилно приложение разработено за операционната система Android, използващо програмния език Kotlin.  

• Регистрация и автентикация на потребителите по стандартен начин, използвайки имейл и парола. Системата поддържа възстановяване на парола чрез имейл.  

Възможност за разглеждане и търсене на рецепти по различни критерии: ▪ По име или ключови думи ▪ По трудност (лесно, средно, трудно) ▪ По време за приготвяне ▪ По категория или кухня  

• Създаване и редактиране на собствени рецепти от потребителите, включващи: ▪ Заглавие и описание ▪ Списък с продукти (съставки) ▪ Стъпки за приготвяне ▪ Време за подготовка и готвене ▪ Брой порции ▪ Снимки на рецептата  

• Управление на списъци с покупки: ▪ Създаване на списък с покупки от избрана рецепта ▪ Добавяне и премахване на продукти ▪ Отбелязване на закупени продукти ▪ Създаване на ръчни списъци с покупки  

• Режим на готвене с интерактивни функции: ▪ Проследяване на стъпките на рецептата ▪ Таймер за време на готвене ▪ Гласови команди за управление на приложението без докосване ▪ Автоматично преминаване към следващата стъпка  

• Интеграция с изкуствен интелект: ▪ AI помощник, който отговаря на въпроси по време на готвене ▪ Персонализирани съвети и препоръки ▪ Помощ при решаване на проблеми по време на приготвяне  

• Социални функции: ▪ Харесване на рецепти ▪ Коментиране на рецепти с възможност за отговори ▪ Преглед на любими рецепти ▪ Преглед на собствените рецепти  

• Административен панел за управление: ▪ Преглед и управление на всички потребители ▪ Блокиране и разблокиране на потребители ▪ Преглед и управление на рецептите ▪ Изтриване на неподходящо съдържание  

• Сървърна част базирана на Spring Boot, предоставяща REST API за комуникация с мобилното приложение.  

• База данни PostgreSQL за съхранение на всички данни на приложението.  

2.2 Избор на технологии за реализацията на мобилното приложение  

2.2.1 Операционна система – Android  

Android операционната система заема значително по-голям дял от пазара на мобилни устройства в сравнение с iOS. Това предимство се обяснява с няколко фактора:  

• По-ниска цена на Android устройствата спрямо тези на Apple  

• По-широка съвместимост на Android операционната система с разнообразни хардуерни платформи  

• По-богат избор от Android устройства на пазара  

• По-голяма свобода и гъвкавост при разработката на приложения за Android в сравнение с iOS платформата  

• По-голяма пазарна проникнатост на Android, което гарантира по-широко разпространение на разработените приложения  

2.2.2 Среда за разработка – Android Studio  

Android Studio се счита за водещата и най-препоръчвана интегрирана среда за разработка на Android приложения. Платформата предлага богат набор от функционалности, които значително ускоряват и опростяват процеса на разработка, сред които са:  

• Визуален редактор за дизайн – дава възможност на разработчиците бързо и интуитивно да конструират различни layout-и чрез drag-and-drop функционалност върху потребителския интерфейс. Това елиминира необходимостта от допълнително писане на код за оформление.  

• APK анализатор – инструмент за анализ на съдържанието на изпълнимия APK файл, който ускорява процеса на откриване и коригиране на проблеми в кодовите файлове и ресурсите. Това допринася за оптимизация на размера на файла, което прави инсталацията по-удобна за устройства с ограничена памет.  

• Виртуален емулатор – Android Studio предоставя възможност за изтегляне и използване на емулатори. Чрез тях разработчиците могат да тестват приложенията си върху различни типове устройства, без да притежават физически такива. Освен това тестването върху емулатор е по-бързо в сравнение с реално устройство.  

• Вградени инструменти за дебъгване и анализ на производителността.  

• Интеграция с Gradle за автоматизиране на build процеса.  

2.2.3 Език за разработка на приложението – Kotlin  

През 2019 година Kotlin е провъзгласен за официален програмен език за Android разработка, замествайки Java като основен език. В настоящето над 60% от специалистите в мобилната разработка прилагат Kotlin, поради множеството предимства, които той предлага:  

• По-кратък код – основна цел при създаването на езика е намаляването на обема на необходимия код, което прави разработката по-ефективна и по-лесна за поддръжка  

• Лесно усвояване – езикът е подходящ за начинаещи програмисти в областта на мобилните приложения  

• Съвременни възможности – защитена система за null стойности, ламбда изрази, механизми за управление на променливост и неизменяемост и други  

• Вградена поддръжка на корутини (coroutines) за паралелно програмиране, което е от особена полза при обработка на мрежови заявки и операции с бази данни  

• Защита срещу null стойности – предотвратява често срещани програмни грешки, свързани с неинициализирани променливи  

2.2.4 Технология за разработка на сървърна част – Spring Boot  

Spring Boot е рамка за разработка на Java приложения, която опростява създаването на RESTful уеб услуги. Основните предимства на Spring Boot са:  

• Висока производителност и мащабируемост  

• Бърза доставка на отговор на заявки  

• Автоматична конфигурация, която намалява необходимостта от ръчна настройка  

• Вградени сървъри (Tomcat, Jetty, Undertow), което позволява бързо стартиране  

• Spring Data JPA за опростена работа с бази данни  

• Spring Security за сигурност и автентикация  

• RESTful API архитектура за комуникация с мобилното приложение  

2.2.5 Система за обработка на бази данни – PostgreSQL  

PostgreSQL е релационна база данни с отворен код, която предоставя мощни възможности за съхранение и управление на данни. Предимствата на PostgreSQL включват:  

• Надеждност и стабилност – PostgreSQL е известна с високата си надеждност и способността да обработва големи обеми данни  

• ACID съвместимост – гарантира целостността на данните при транзакции  

• Богат набор от типове данни – поддържа различни типове данни, включително JSON, масиви и географски данни  

• Разширяемост – позволява създаване на собствени типове данни и функции  

• Поддръжка на сложни заявки и съединения между таблици  

• Безплатна и с отворен код  

2.3 Структура и основни компоненти на мобилното приложение  

2.3.1 Activity  

Activity е входната точка на взаимодействието на потребителя с мобилното приложението. Едно activity обикновено представлява един екран с потребителски интерфейс. Всяко activity има свой жизнен цикъл, който се променя в зависимост от състоянието на приложението.  

В приложението ChefMate се използват следните основни Activities:  

• LoginActivity – екран за вход в приложението, който потребителите виждат при първото отваряне  

• MainActivity – основното activity, което служи като контейнер за фрагментите и управлява навигацията в приложението  

• RegisterActivity – екран за регистрация на нови потребители  

• ProfileActivity – екран за преглед и редактиране на потребителския профил  

2.3.2 Fragment  

Fragment представлява преизползваема част от потребителския интерфейс. Фрагментите управляват собственото си оформление и сами могат да обработват събитията, които се случват вътре в тях. Въпреки това един фрагмент не може да съществува самостоятелно – трябва да бъде хостван (приютен) от едно Activity.  

Всеки фрагмент има свой собствен жизнен цикъл, различен от този на Activity, но пряко зависещ от него. За добавянето, изтриването или заменянето на фрагменти се използва класът FragmentManager.  

В приложението ChefMate се използват следните основни Fragments:  

• RecipeListFragment – показва списък с рецепти с възможност за търсене и филтриране  

• RecipeDetailFragment – показва подробна информация за избрана рецепта  

• AddRecipeFragment – позволява създаване и редактиране на рецепти  

• ShoppingListFragment – показва списъците с покупки на потребителя  

• CookingModeFragment – режим на готвене с интерактивни функции  

• AiChatFragment – интерфейс за комуникация с AI помощника  

• ProfileFragment – преглед на потребителския профил  

2.3.3 Single-Activity Architecture  

През 2018 г. Google обявява Jetpack и Navigation component, с което се появява и една нова архитектура – единично Activity. От тогава до сега тази архитектура е предпочитаният начин за създаване на Android приложения. При нея вместо едно Activity да бъде един екран, то се разглежда като контейнер пълен с фрагменти. Това носи редица плюсове:  

• Писане на по-малко код  

• Обменът на информация между различните екрани става значително по-лесно  

• По-чиста анимация при смяна на екрани  

• По-добра производителност, тъй като се избягва създаването на множество Activities  

В ChefMate се използва MainActivity като единствено Activity, което служи като контейнер за всички фрагменти, управлявани от Navigation Component.  

2.3.4 MVVM  

MVVM (Model-View-ViewModel) е архитектурен модел, чиято цел е да раздели разработката на графичния интерфейс от тази на бизнес логиката. Структурата на модела се състои от 3 компонента:  

• Model – Използва се като контейнер, съдържащ информацията помещаваща се в приложението. Не се вижда от потребителя. В ChefMate моделите представляват данните, получени от REST API.  

• View – Представлява оформлението, което потребителят вижда на екрана. От него се получават данните за взаимодействие на потребителя с отделните компоненти на приложението, след което се препращат за обработка към ViewModel. В ChefMate View се реализира чрез Fragments и Activities.  

• ViewModel – Играе ролята на посредник (връзка) между Model и View. В него се обработва въведената от потребителя информация. След това резултатът може да бъде запазен в Model или чрез използването на специален тип данни, наречен StateFlow/LiveData, да бъде показан на View, за да се извършат промени по потребителския интерфейс. За комуникация със сървърната част ViewModel използва Repository класове.  

В ChefMate се използват следните ViewModels:  

• AuthViewModel – управлява автентикацията и регистрацията  

• RecipeViewModel – управлява списъка с рецепти, търсенето и филтрирането  

• RecipeDetailViewModel – управлява детайлната информация за рецепта  

• AddRecipeViewModel – управлява създаването и редактирането на рецепти  

• ShoppingListViewModel – управлява списъците с покупки  

• CookingModeViewModel – управлява режима на готвене  

• AiViewModel – управлява комуникацията с AI помощника  

2.3.5 Repository Pattern  

Repository Pattern е дизайн модел, който абстрахира достъпа до данни и предоставя по-чист API за достъп до данни. В ChefMate Repository класовете са отговорни за:  

• Комуникация с REST API чрез Retrofit  

• Кеширане на данни локално  

• Управление на състоянието на данните  

• Обработка на грешки  

В приложението се използват следните Repository класове:  

• AuthRepository – управлява автентикацията и регистрацията  

• RecipeRepository – управлява операциите с рецепти  

• ShoppingRepository – управлява списъците с покупки  

• AiRepository – управлява комуникацията с AI услугата  

• AdminRepository – управлява административните функции  

2.4 Структура на базата данни  

Базата данни на мобилното приложение е изградена с помощта на PostgreSQL и се състои от следните основни таблици:  

2.4.1 Таблица Users  

В нея се пази цялата информация, която е свързана с потребителските профили. Полетата, които съдържа са:  

• id – уникален идентификатор (primary key)  

• username – потребителско име (уникално)  

• email – имейл адрес (уникален)  

• password – паролата на потребителя в криптиран вид (хеширана с BCrypt)  

• first_name – първо име на потребителя  

• last_name – фамилия на потребителя  

• profile_image_url – URL към снимката на профила  

• role – роля на потребителя (USER, ADMIN)  

• enabled – дали профилът е активиран  

• created_at – дата на създаване на профила  

• updated_at – дата на последна актуализация  

2.4.2 Таблица Recipes  

Съдържа информация за всички рецепти в приложението. Полетата, които съдържа са:  

• id – уникален идентификатор (primary key)  

• title – заглавие на рецептата  

• description – описание на рецептата  

• prep_time – време за подготовка в минути  

• cook_time – време за готвене в минути  

• total_time – общо време в минути  

• servings – брой порции  

• difficulty – трудност (EASY, MEDIUM, HARD)  

• image_url – основна снимка на рецептата  

• user_id – идентификатор на потребителя, създал рецептата (foreign key към Users)  

• likes_count – брой харесвания  

• views_count – брой преглеждания  

• created_at – дата на създаване  

• updated_at – дата на последна актуализация  

Допълнителни таблици, свързани с рецептите:  

• recipe_ingredients – съдържа списъка с продукти за всяка рецепта  

• recipe_steps – съдържа стъпките за приготвяне на всяка рецепта  

• recipe_image_urls – съдържа допълнителни снимки за рецептата  

2.4.3 Таблица Comments  

Съдържа коментарите към рецептите. Полетата, които съдържа са:  

• id – уникален идентификатор (primary key)  

• content – съдържание на коментара  

• recipe_id – идентификатор на рецептата (foreign key към Recipes)  

• user_id – идентификатор на потребителя, написал коментара (foreign key към Users)  

• parent_comment_id – идентификатор на родителския коментар (за отговори, foreign key към Comments)  

• created_at – дата на създаване  

2.4.4 Таблица Recipe_Likes  

Съдържа информация за харесванията на рецептите. Полетата, които съдържа са:  

• id – уникален идентификатор (primary key)  

• recipe_id – идентификатор на рецептата (foreign key към Recipes)  

• user_id – идентификатор на потребителя (foreign key към Users)  

• Уникална комбинация от recipe_id и user_id предотвратява дублиране на харесвания  

2.4.5 Таблица Shopping_Lists  

Съдържа списъците с покупки на потребителите. Полетата, които съдържа са:  

• id – уникален идентификатор (primary key)  

• name – име на списъка с покупки  

• user_id – идентификатор на потребителя (foreign key към Users)  

• completed – дали списъкът е завършен  

• created_at – дата на създаване  

2.4.6 Таблица Shopping_List_Items  

Съдържа елементите от списъците с покупки. Полетата, които съдържа са:  

• id – уникален идентификатор (primary key)  

• shopping_list_id – идентификатор на списъка с покупки (foreign key към Shopping_Lists)  

• name – име на продукта  

• quantity – количество  

• checked – дали продуктът е закупен  

2.4.7 Таблица Password_Reset_Tokens  

Съдържа токени за възстановяване на пароли. Полетата, които съдържа са:  

• id – уникален идентификатор (primary key)  

• token – уникален токен за възстановяване  

• user_id – идентификатор на потребителя (foreign key към Users)  

• expiry_date – дата на изтичане на токена  

2.4.8 Структура на екраните  

Структурата на екраните представлява съвкупност от фрагменти, управлявани от Navigation Component. Всеки един от тях играе ролята на различен екран, който се вижда от потребителя и изпълнява дадена функционалност. Основните екрани са:  

• LoginActivity – това е първият екран, който потребителите виждат, когато отворят приложението. От него те могат да влязат в профилите си или да се регистрират.  

• MainActivity – основното activity, което служи като контейнер за всички фрагменти. Съдържа долна навигационна лента с табове за:  

Рецепти (RecipeListFragment)  

Любими рецепти (LikedRecipesFragment)  

Списък с покупки (ShoppingListFragment)  

AI помощник (AiChatFragment)  

Профил (ProfileFragment)  

• RecipeDetailFragment – показва подробна информация за избрана рецепта, включително съставки, стъпки, коментари и възможност за харесване.  

• AddRecipeFragment – позволява на потребителите да създават и редактират собствени рецепти.  

• CookingModeFragment – режим на готвене с интерактивни функции, включително проследяване на стъпки, таймер и гласови команди.  

• ProfileActivity – екран за преглед и редактиране на потребителския профил, включително собствените рецепти на потребителя.  

3. Трета глава: Реализация на мобилното приложение 

3.1 Структура на проекта  

Проектът ChefMate е организиран в следната структура:  

• AndroidManifest.xml – съхранява XML файл с метаданни, които описват информация за приложението, функционалности и изисквания към операционната система Android. Дефинира разрешенията, activities, services и други компоненти на приложението.  

• Java (Kotlin) – съхранява Kotlin файловете на проекта. Съдържа три поддиректории – същинска част на проекта и две тестови директории. Същинската част (com.chefmate), включва следните основни пакети:  

data – съдържа API клиент, модели на данни и repository класове  

ui – съдържа всички UI компоненти (Activities, Fragments, ViewModels, Adapters)  

utils – помощни класове и утилити  

service – background services (TimerService)  

di – dependency injection модули  

• Res – съхранява XML файлове. Разделя се на следните поддиректории:  

drawable – векторни икони и drawable ресурси  

layout – XML файлове за оформление на екраните  

menu – XML файлове за менюта  

mipmap – икони на приложението  

navigation – навигационни графи за Navigation Component  

values – стойности като strings, colors, themes  

xml – допълнителни XML конфигурации  

За процесът по компилиране на проекта и свързване на всички негови съставни части се грижи автоматизираната система Gradle. Към принадлежащите му файлове са добавени библиотеките, които са нужни на приложението. Файловете са два – за цялостната система и модулен.  

Най-важният принцип, който е следван при изграждането на проекта, е разпределението на отговорности.  

Фрагменти са базирани на UI класове, които да съдържат само логиката, която обработва взаимодействията на UI и операционната система.  

Activity и Fragment са свързващи класове, които представляват договора между Android OS и приложението.  

Друг важен принцип е управляването на потребителския интерфейс от модели на данни. Моделите на данни представляват данните на приложението. Те са независими от елементите на потребителския интерфейс и другите компоненти.  

Спрямо тези принципи приложението има два слоя:  

• Слой на потребителския интерфейс, който показва данните на приложението на екрана (Fragment файлове)  

• Слой с данни, който съдържа бизнес логиката и излага данните на приложението (ViewModel и Repository файлове)  

3.2 Реализация на приложението: Програмна част  

Приложението използва Single-Activity Architecture с MainActivity като единствено Activity, което служи като контейнер за всички фрагменти. Навигацията се управлява от Navigation Component.  

За извеждането на данни под формата на лист от елементи се използва RecyclerView, като за всяко е дефиниран клас Adapter, който служи за това данните да бъдат адаптирани към зададения стил.  

Използвана е StateFlow (от Kotlin Coroutines), за промяна на стойности в реално време, които да бъдат отразявани на екраните на потребителите. StateFlow е модерна алтернатива на LiveData, която предоставя реактивен поток от данни.  

За придвижването между екраните в приложението са използвани библиотеките:  

androidx.navigation:navigation-fragment-ktx  

androidx.navigation:navigation-ui-ktx  

Главният навигационен файл е nav_graph.xml, който се намира в директорията navigation.  

За комуникация със сървърната част се използва Retrofit:  

com.squareup.retrofit2:retrofit  

com.squareup.retrofit2:converter-gson  

За асинхронно програмиране се използват Kotlin Coroutines:  

org.jetbrains.kotlinx:kotlinx-coroutines-android  

За зареждане и кеширане на изображения се използва Glide:  

com.github.bumptech.glide:glide  

3.2.1 Реализация на функционалности за потребители  

3.2.1.1 Регистрация и автентикация  

За да могат да използват приложението, потребителите трябва да се регистрират или да влязат в съществуващия си профил. 

Регистрацията се осъществява чрез RegisterActivity, където потребителят въвежда потребителско име, имейл и парола. От AuthViewModel се извиква методът register(), който изпраща заявка към REST API чрез AuthRepository. При успешна регистрация, токенът за автентикация се запазва локално чрез TokenManager и потребителят се пренасочва към MainActivity. 

Следва примерен код на AuthViewModel: 

class AuthViewModel( 
   private val repository: AuthRepository = AuthRepository() 
) : ViewModel() { 
 
   private val _authState = MutableStateFlow<AuthState>(AuthState.Idle) 
   val authState: StateFlow<AuthState> = _authState 
 
   fun login(email: String, password: String) { 
       viewModelScope.launch { 
           _authState.value = AuthState.Loading 
           val result = repository.login(email, password) 
           result.onSuccess { response -> 
               _authState.value = AuthState.Success(response.token) 
           }.onFailure { error -> 
               _authState.value = AuthState.Error(error.message ?: "Login failed") 
           } 
       } 
   } 
 
   fun register(name: String, email: String, password: String) { 
       viewModelScope.launch { 
           _authState.value = AuthState.Loading 
           val result = repository.register(name, email, password) 
           result.onSuccess { response -> 
               _authState.value = AuthState.Success(response.token) 
           }.onFailure { error -> 
               _authState.value = AuthState.Error(error.message ?: "Registration failed") 
           } 
       } 
   } 
} 
 

Входът в приложението се осъществява чрез LoginActivity. Потребителят въвежда имейл и парола, след което от AuthViewModel се извиква методът login(). Той изпраща заявка към REST API и при успешна автентикация получава JWT токен, който се запазва за последващи заявки. 

За възстановяване на парола се използва ForgotPasswordActivity, който изпраща заявка за генериране на токен за възстановяване. Токенът се изпраща на имейл адреса на потребителя, който може да го използва в ResetPasswordActivity за задаване на нова парола.  

3.2.1.2 Разглеждане и търсене на рецепти  

Рецептите се показват в RecipeListFragment, който използва RecyclerView с RecipeAdapter за визуализация. При зареждане на фрагмента, от RecipeViewModel се извиква методът loadRecipes(), който извлича всички рецепти от сървъра чрез RecipeRepository. 

Следва примерен код на RecipeViewModel за зареждане и търсене на рецепти: 

class RecipeViewModel( 
   private val recipeRepository: RecipeRepository 
) : ViewModel() { 
 
   private val _recipes = MutableStateFlow<List<RecipeResponse>>(emptyList()) 
   val recipes: StateFlow<List<RecipeResponse>> = _recipes.asStateFlow() 
 
   private val _isLoading = MutableStateFlow(false) 
   val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow() 
 
   fun loadRecipes() { 
       viewModelScope.launch { 
           _isLoading.value = true 
           _error.value = null 
 
           recipeRepository.getRecipes() 
               .onSuccess { recipes -> 
                   _recipes.value = recipes 
               } 
               .onFailure { exception -> 
                   _error.value = exception.message ?: "Error loading recipes" 
               } 
 
           _isLoading.value = false 
       } 
   } 
 
   fun searchRecipes(query: String) { 
       viewModelScope.launch { 
           _isLoading.value = true 
           _error.value = null 
 
           recipeRepository.searchRecipes( 
               query = if (query.isBlank()) null else query, 
               difficulty = _selectedDifficulty.value, 
               maxTime = _selectedMaxTime.value 
           ) 
               .onSuccess { recipes -> 
                   _recipes.value = recipes 
               } 
               .onFailure { exception -> 
                   _error.value = exception.message ?: "Error searching" 
               } 
 
           _isLoading.value = false 
       } 
   } 
} 
 

Потребителите могат да търсят рецепти по име или ключови думи чрез полето за търсене. При въвеждане на текст, от RecipeViewModel се извиква методът searchRecipes(query), който изпраща заявка към API с параметъра за търсене. 

Филтрирането на рецепти се осъществява по два критерия: 

• По трудност (EASY, MEDIUM, HARD) – чрез методът filterByDifficulty() 

• По максимално време за приготвяне – чрез методът filterByTime() 

Филтрите се прилагат комбинирано и резултатите се актуализират в реално време чрез StateFlow. 

За визуализация на изображенията на рецептите се използва библиотеката Glide, която автоматично кешира снимките и оптимизира тяхното зареждане.  

3.2.1.3 Преглед на детайли за рецепта  

При избиране на рецепта от списъка, потребителят се пренасочва към RecipeDetailFragment. Чрез навигацията се предава ID на рецептата като аргумент.  

В RecipeDetailFragment се извиква методът loadRecipe(recipeId) от RecipeDetailViewModel, който извлича пълната информация за рецептата от сървъра. Рецептата се показва с:  

Заглавие и описание  

Списък със съставки (чрез IngredientAdapter)  

Стъпки за приготвяне (чрез StepAdapter)  

Снимки на рецептата (чрез RecipeImageAdapter с ViewPager2)  

Информация за време, порции и трудност  

Бутон за харесване  

Секция с коментари  

Потребителите могат да харесват рецепта чрез методът toggleLike() от RecipeDetailViewModel, който изпраща заявка за добавяне или премахване на харесване.  

3.2.1.4 Създаване и редактиране на рецепти  

Потребителите могат да създават собствени рецепти чрез AddRecipeFragment. Формата включва:  

Заглавие и описание  

Време за подготовка, готвене и общо време  

Брой порции  

Трудност  

Списък със съставки (с възможност за добавяне и премахване)  

Стъпки за приготвяне (с възможност за добавяне и премахване)  

Качване на снимки (чрез камера или галерия)  

При запазване на рецепта, от AddRecipeViewModel се извиква методът createRecipe(), който изпраща данните към REST API. Снимките се качват като multipart/form-data заявки.  

За редактиране на съществуваща рецепта се използва същият фрагмент, но с предварително заредени данни. Методът updateRecipe() от AddRecipeViewModel изпраща актуализираните данни към сървъра.  

3.2.1.5 Управление на списъци с покупки  

Потребителите могат да създават списъци с покупки от рецепти или ръчно. В ShoppingListFragment се показват всички списъци на потребителя чрез ShoppingAdapter.  

При избиране на рецепта, потребителят може да създаде списък с покупки от нейните съставки чрез методът createShoppingListFromRecipe() от ShoppingListViewModel. Това автоматично създава нов списък и добавя всички съставки от рецептата.  

В детайлния екран на списъка се показват всички продукти чрез ShoppingListItemAdapter. Потребителите могат:  

Да отбележат продукти като закупени (чрез updateItem())  

Да добавят нови продукти (чрез addItem())  

Да премахнат продукти (чрез deleteItem())  

Всички промени се синхронизират с сървъра в реално време.  

3.2.1.6 Режим на готвене  

Режимът на готвене е една от ключовите функционалности на приложението. Той се активира от RecipeDetailFragment и отваря CookingModeFragment. 

В CookingModeViewModel се управлява състоянието на сесията за готвене чрез CookingSessionState, което включва: 

• Текущата рецепта 

• Текущата стъпка 

• Използваните съставки 

• Състоянието на таймера 

Следва примерен код на CookingModeViewModel: 

class CookingModeViewModel(private val context: android.content.Context) : ViewModel() { 
   private val tokenManager = TokenManager(context) 
   private val aiRepository = AiRepository(tokenManager) 
    
   private val _sessionState = MutableStateFlow(CookingSessionState()) 
   val sessionState: StateFlow<CookingSessionState> = _sessionState.asStateFlow() 
    
   fun startCookingSession(recipe: RecipeResponse) { 
       _sessionState.value = CookingSessionState( 
           recipe = recipe, 
           currentStep = 0, 
           totalSteps = recipe.steps.size, 
           usedIngredients = emptyList(), 
           cookingStage = "preparation", 
           currentAction = if (recipe.steps.isNotEmpty()) recipe.steps[0] else null 
       ) 
   } 
    
   fun nextStep() { 
       val state = _sessionState.value 
       val recipe = state.recipe ?: return 
       val nextStepIndex = state.currentStep + 1 
        
       if (nextStepIndex < recipe.steps.size) { 
           _sessionState.value = state.copy( 
               currentStep = nextStepIndex, 
               currentAction = recipe.steps[nextStepIndex] 
           ) 
       } 
   } 
    
   fun previousStep() { 
       val state = _sessionState.value 
       val prevStepIndex = state.currentStep - 1 
        
       if (prevStepIndex >= 0) { 
           _sessionState.value = state.copy( 
               currentStep = prevStepIndex, 
               currentAction = state.recipe?.steps?.get(prevStepIndex) 
           ) 
       } 
   } 
} 
 

Потребителите могат да: 

• Преминават към следващата стъпка (чрез nextStep()) 

• Връщат се към предишната стъпка (чрез previousStep()) 

• Стартират таймер за време на готвене (чрез startTimer()) 

• Паузират и възобновяват таймера (чрез pauseTimer() и resumeTimer()) 

Таймерът се управлява от TimerService, който работи като foreground service и продължава да работи дори когато приложението е в background.  

3.2.1.7 Гласови команди в режим на готвене  

Една от иновативните функционалности е възможността за управление на приложението чрез гласови команди по време на готвене. Това е особено полезно, когато ръцете на потребителя са мръсни.  

Гласовото разпознаване се осъществява чрез Android SpeechRecognizer API, обвит в MlKitSpeechRecognizer за по-добра точност. Потребителят може да дава команди като:  

"Следваща стъпка"  

"Предишна стъпка"  

"Стартирай таймер за X минути"  

"Пауза"  

"Продължи"  

Командите се обработват в CookingModeFragment и се изпращат към CookingModeViewModel за изпълнение.  

3.2.1.8 AI помощник  

Потребителите могат да получават помощ от AI помощник по време на готвене. В CookingAssistantFragment (или в режим на готвене) потребителят може да задава въпроси.  

Въпросите се изпращат чрез методът sendMessage() от AiViewModel, който извиква AiRepository. Repository-то изпраща заявка към REST API с контекста на текущата рецепта и сесията за готвене.  

AI помощникът може да отговаря на въпроси като:  

"Как да приготвя тази стъпка?"  

"Какво да правя, ако нямам този продукт?"  

"Колко време трябва да готвя?"  

Отговорите се показват в реално време в чат интерфейса чрез ChatAdapter.  

3.2.1.9 Коментари и взаимодействие  

Потребителите могат да коментират рецепти в RecipeDetailFragment. Коментарите се показват чрез CommentAdapter и поддържат:  

Основни коментари  

Отговори на коментари (чрез parentCommentId)  

Добавянето на коментар се осъществява чрез методът addComment() от RecipeDetailViewModel, който изпраща заявка към API.  

Потребителите могат също да харесват коментари, което се управлява от backend-а.  

3.2.1.10 Преглед на любими рецепти  

В LikedRecipesFragment потребителите могат да видят всички рецепти, които са харесали. Фрагментът използва същия RecipeAdapter като основния списък, но филтрира рецептите по харесвания.  

3.2.1.11 Профил на потребителя  

В ProfileActivity потребителят може да:  

Преглежда информацията за своя профил  

Редактира профила си (име, снимка)  

Преглежда собствените си рецепти (чрез UserRecipesFragment)  

Излиза от профила си  

3.2.2 Реализация на функционалности за администратори  

3.2.2.1 Вход като администратор  

Администраторите влизат в приложението по същия начин като обикновените потребители, но техният профил има роля ADMIN. При влизане, AuthViewModel проверява ролята на потребителя и ако е ADMIN, предоставя достъп до административните функции.  

3.2.2.2 Управление на потребители  

В AdminFragment администраторът може да вижда списък с всички потребители чрез UserAdapter. Администраторът може:  

Да блокира потребители (чрез blockUser() от AdminViewModel)  

Да разблокира потребители (чрез unblockUser())  

Да изтрива потребители (чрез deleteUser())  

Всички операции се изпращат към REST API чрез AdminRepository.  

3.2.2.3 Управление на рецепти  

Администраторът може да управлява всички рецепти в системата. В RecipeListFragment, ако потребителят е администратор, се показват допълнителни опции:  

Изтриване на рецепти (чрез deleteRecipe() от RecipeDetailViewModel)  

Редактиране на рецепти  

Администраторът има пълен достъп до всички рецепти, независимо от техния автор.  

3.3 Използвани библиотеки и технологии  

Приложението използва следните основни библиотеки:  

• Retrofit – за HTTP заявки към REST API • Gson – за сериализация и десериализация на JSON • Kotlin Coroutines – за асинхронно програмиране • StateFlow – за реактивни потоци от данни • Glide – за зареждане и кеширане на изображения • Navigation Component – за навигация между екраните • ViewBinding – за типобезопасен достъп до view елементи • Material Design Components – за модерен UI дизайн • ML Kit – за разпознаване на реч • UCrop – за обработка на изображения 

4. Четвърта глава: Ръководство на потребителя 

4.1 Инсталация  

Приложението може да бъде инсталирано и изпълнено единствено на мобилни устройства с Android система.  

Устройството трябва да бъде свързано към компютъра с USB.  

В настройките на устройството трябва да бъдат активирани „Опции на програмиста", от които да се разреши опцията „Инсталиране през USB". (На различните модели телефони е възможно до тази опция да се стига по различен начин и да има разлики в наименованието).  

Файлът на приложението е app-debug.apk. Той може да бъде инсталиран на мобилно устройство през терминала на компютъра с помощта на Android Debug Bridge (adb). (Инсталиране на adb - https://www.xda-developers.com/install-adb-windows-macos-linux/)  

Въведете командата adb devices, за да разберете как се казва свързаното устройство. След това въведете командата adb -s име на устройство install -t app-debug.apk.  

След като приложението е успешно инсталирано, то е готово за употреба.  

Проектът може да бъде стартиран през Android Studio, което автоматично го инсталира на свързаното устройство.  

Важно: Преди да използвате приложението, трябва да се уверите, че backend сървърът е стартиран и достъпен. По подразбиране приложението се свързва към http://localhost:8090 при разработка или към адреса на production сървъра.  

4.2 Описание на продукта  

4.2.1 Екран за вход  

При отварянето на приложението потребителите виждат екрана за вход (LoginActivity). Тук могат да:  

• Влязат в съществуващия си профил, като въведат имейл и парола  

• Регистрират нов профил, като натиснат бутона "Register"  

• Възстановят забравена парола, като натиснат "Forgot Password?"  

При успешен вход, потребителят се пренасочва към основния екран на приложението (MainActivity).  

4.2.2 Основен екран  

След влизане в приложението, потребителите виждат основния екран с долна навигационна лента, която съдържа следните табове:  

• Рецепти – показва списък с всички рецепти  

• Любими – показва рецептите, които потребителят е харесал  

• Списък с покупки – показва списъците с покупки на потребителя  

• AI помощник – отваря интерфейса за комуникация с AI помощника  

• Профил – показва информация за потребителя  

4.2.3 Потребител с роля "Потребител"  

4.2.3.1 Разглеждане на рецепти  

На екрана "Рецепти" се извежда списък от всички рецепти в приложението. Рецептите са подредени в мрежа (grid layout) и всяка показва:  

• Снимка на рецептата  

• Заглавие  

• Време за приготвяне  

• Трудност  

• Брой харесвания  

Потребителите могат да:  

• Търсят рецепти – чрез полето за търсене в горната част на екрана могат да въведат име или ключови думи  

• Филтрират рецепти – чрез бутоните за филтриране могат да изберат:  

Трудност (Лесно, Средно, Трудно)  

Максимално време за приготвяне  

• Избират рецепта – при натискане на рецепта се отваря екран с подробна информация  

4.2.3.2 Детайли за рецепта  

На екрана с детайли за рецепта потребителите виждат:  

• Заглавие и описание на рецептата  

• Снимки на рецептата (с възможност за преглеждане на множество снимки)  

• Информация за време (подготовка, готвене, общо), порции и трудност  

• Списък със съставки (продукти)  

• Стъпки за приготвяне  

• Бутон за харесване  

• Секция с коментари  

• Бутон "Започни готвене" – отваря режима на готвене  

• Бутон "Добави към списък с покупки" – създава списък с покупки от съставките  

Потребителите могат да:  

• Харесват рецепта – чрез бутона за харесване  

• Коментират рецепта – чрез полето за коментари в долната част на екрана  

• Отговарят на коментари – чрез бутона "Отговори" под всеки коментар  

• Започнат готвене – чрез бутона "Започни готвене", който отваря режима на готвене  

4.2.3.3 Създаване на рецепта  

Потребителите могат да създават собствени рецепти чрез бутона "Добави рецепта" в екрана с рецепти или от профила си.  

Формата за създаване на рецепта включва:  

• Заглавие и описание  

• Време за подготовка, готвене и общо време (в минути)  

• Брой порции  

• Трудност (Лесно, Средно, Трудно)  

• Списък със съставки – с възможност за добавяне и премахване на продукти  

• Стъпки за приготвяне – с възможност за добавяне и премахване на стъпки  

• Качване на снимки – чрез камера или галерия  

След попълване на формата, потребителят натиска бутона "Запази", за да публикува рецептата.  

4.2.3.4 Списъци с покупки  

На екрана "Списък с покупки" потребителите виждат всички свои списъци с покупки. Могат да:  

• Създадат нов списък – чрез бутона "Нов списък"  

• Създадат списък от рецепта – от детайлите на рецепта, чрез бутона "Добави към списък с покупки"  

• Преглеждат списък – при натискане на списък се отваря детайлен екран  

• Изтрият списък – чрез бутона за изтриване  

В детайлния екран на списъка потребителите виждат всички продукти и могат да:  

• Отбележат продукти като закупени – чрез checkbox-овете пред всеки продукт  

• Добавят нов продукт – чрез бутона "Добави продукт"  

• Премахнат продукт – чрез бутона за изтриване  

4.2.3.5 Режим на готвене  

Режимът на готвене е една от ключовите функционалности на приложението. Той се активира от детайлите на рецепта чрез бутона "Започни готвене".  

В режима на готвене потребителите виждат:  

• Текущата стъпка от рецептата  

• Прогрес бар, показващ на коя стъпка са  

• Бутони за навигация:  

"Предишна стъпка"  

"Следваща стъпка"  

• Таймер за готвене – с възможност за стартиране, пауза и спиране  

• Бутон за гласови команди – позволява управление на приложението чрез глас  

• Бутон за AI помощ – отваря AI помощника с контекст на текущата рецепта  

Режимът на готвене е оптимизиран за използване по време на готвене, с големи бутони и ясен интерфейс.  

4.2.3.6 Гласови команди  

В режима на готвене потребителите могат да управляват приложението чрез гласови команди, което е особено полезно, когато ръцете им са мръсни.  

За да активират гласовите команди, потребителят натиска бутона с микрофон. След това може да дава команди като:  

• "Следваща стъпка" – преминава към следващата стъпка  

• "Предишна стъпка" – връща се към предишната стъпка  

• "Стартирай таймер за X минути" – стартира таймер за определено време  

• "Пауза" – паузира таймера  

• "Продължи" – възобновява таймера  

• "Спри таймера" – спира таймера  

4.2.3.7 AI помощник  

AI помощникът позволява на потребителите да получават помощ по време на готвене. Той е достъпен от:  

• Основния екран – чрез таба "AI помощник"  

• Режима на готвене – чрез бутона "AI помощ"  

В интерфейса на AI помощника потребителите могат да задават въпроси като:  

• "Как да приготвя тази стъпка?"  

• "Какво да правя, ако нямам този продукт?"  

• "Колко време трябва да готвя?"  

• "Как да заменя този продукт?"  

AI помощникът отговаря с персонализирани съвети, базирани на текущата рецепта и контекста на готвенето.  

4.2.3.8 Любими рецепти  

На екрана "Любими" потребителите виждат всички рецепти, които са харесали. Рецептите се показват в същия формат като основния списък и могат да бъдат отворени за преглед или готвене.  

4.2.3.9 Профил на потребителя  

На екрана "Профил" потребителите виждат:  

• Информация за профила си (име, имейл, снимка)  

• Собствените си рецепти – чрез бутона "Моите рецепти"  

• Възможност за редактиране на профила  

• Възможност за излизане от профила  

При натискане на "Моите рецепти", потребителят вижда списък с всички рецепти, които е създал, и може да ги редактира или изтрива.  

4.2.4 Потребител с роля "Администратор"  

Администраторите имат достъп до допълнителни функции за управление на приложението.  

4.2.4.1 Административен панел  

Администраторът може да достъпи административния панел от профила си чрез бутона "Администрация".  

В административния панел администраторът може да:  

• Управлява потребители – вижда списък с всички потребители и може да:  

Блокира потребители  

Разблокира потребители  

Изтрива потребители  

• Управлява рецепти – вижда всички рецепти в системата и може да:  

Изтрива неподходящи рецепти  

Редактира рецепти  

Всички операции се извършват чрез REST API и се синхронизират с базата данни.  

5. Заключение 

С дипломната работа е постигнато разработването на мобилно приложение за управление на рецепти, което интегрира множество иновативни функционалности в една платформа. Приложението ChefMate предоставя пълноценно решение за начинаещи и опитни готвачи, като улеснява процеса на приготвяне на храна чрез модерни технологии и интуитивен потребителски интерфейс. 

Основните постижения включват успешната реализация на всички планирани функционалности: система за управление на рецепти с търсене и филтриране, интерактивен режим на готвене с гласови команди, AI помощник за съвети по време на готвене, управление на списъци с покупки и социални функции за взаимодействие между потребителите. Приложението използва модерна архитектура с MVVM модел, REST API комуникация и PostgreSQL база данни, което осигурява добра производителност, мащабируемост и поддръжка. 

За бъдещо развитие на проекта се предвиждат подобрения като добавяне на видео инструкции, интеграция с доставчици на храни, планиране на меню за седмицата, офлайн режим и разширяване на AI функционалностите. Приложението има потенциал да се развие в пълноценна платформа за готвене с голяма общност от потребители. 

6. Използвана литература 

[1] Android Platform Architecture. Developer Android. https://developer.android.com/guide/platform 

[2] Kotlin Programming Language. Kotlin Official Website. https://kotlinlang.org/ 

[3] Android Studio. Developer Android. https://developer.android.com/studio 

[4] Spring Boot. Spring Official Documentation. https://spring.io/projects/spring-boot 

[5] AllRecipes. https://www.allrecipes.com/ 

[6] Yummly. https://yummlyrecipe.com/ 

[7] Tasty. BuzzFeed Tasty. https://www.tasty.co/ 

[8] PostgreSQL Documentation. PostgreSQL Global Development Group. https://www.postgresql.org/docs/ 

[9] Retrofit Documentation. Square, Inc. https://square.github.io/retrofit/ 

[10] Kotlin Coroutines Guide. Kotlin Official Documentation. https://kotlinlang.org/docs/coroutines-guide.html 

[11] Android Architecture Components. Developer Android. https://developer.android.com/topic/libraries/architecture 

[12] Material Design Guidelines. Google. https://material.io/design 

[13] Android Navigation Component. Developer Android. https://developer.android.com/guide/navigation 

[14] Glide Image Loading Library. Bumptech. https://bumptech.github.io/glide/ 

[15] ML Kit for Firebase. Google. https://developers.google.com/ml-kit 

 